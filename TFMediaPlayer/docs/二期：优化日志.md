始18.9.21

1. 没有数据时，通知上传暂停音频播放；等数据积攒到一定程度，再由恢复。要有一个对于当前本地数据存有状况、获取状况的一个监控。
2. 对条件锁的使用理解有误：锁的意义就是把“条件-操作”绑定为一个整体，保证你的操作是正确的。如果根据条件作了判断后，条件被修改了，那么后面的操作就错误了。也是为了保证先后顺序：
	
 ```
 //线程1
 if (A){
 	//位置1
 	wait;
 }
 //线程2
 A = false;
 signal;
 ```
 线程2的代码如果在位置的时间点执行，那么线程1就会永远卡死。需要改成:
 
 ```
 //线程1
 lock
 if (A){
 	//位置1
 	wait;
 }
 unlock
 
 //线程2
 lock
 A = false;
 signal;
 unlock
 ```
 
 为了性能考虑，某些地方的条件修改可以不加锁，只要保证线程1判断内部的代码执行不会因为A的只改变而变得无意义。
 
3. 需要wait和signal的,注意signal可能发生在wait之前，所以需要有一个条件伴随，用来判断是否已经signal了，已经signal了就不需要wait
4. 如果出现一个缓冲区满了，另一个空了的时候怎么办？只能依靠“音视频同步一定是对的”吗？
5. 针对4查到的问题还是代码的问题：检测的viewFrame,作为buffering的标准，外界在buffering的时候关闭了音频播放，导致音频堆积。应该是要以audioFrame的数量来判断。
6. 频繁切换资源地址还是有一些问题，而且又是已经连接了成功，ready了却停止播放
7. `av_format_open`阻塞超时，无法取消，导致下一个资源无法及时打开。
8. 释放资源时的加解锁模式可以抽象出来
9. 音频audioQueue有时会停止播放，回调函数不调用。
10. 暂停后，时间会出现跳跃，在加载不顺畅的视频里出现比较多。流畅的几乎不会出现。
11. 暂停后，留在loop中的frame会继续运行，导致同步锁syncClock的时间标记出错。等到暂停结束，标准是往前推的，导致许多frame被丢弃，导致时间往前跳。**从这可以看出，这个架构里棘手的花费掉我大量时间的是frame数据的清洗，stop flush pause时不能控制好frame会导致错误**